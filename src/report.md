## Part 1. Настройка gitlab-runner

- **Подняли виртуальную машину Ubuntu Server 20.04 LTS**
![image](./images/1.1.png)

- **Скачали и установили на виртуальную машину gitlab-runner**
![image](./images/1.2.png)

- **Запустили **gitlab-runner** и зарегистрировали его для использования в текущем проекте (*DO6_CICD*)**
![image](./images/1.3.png)

## Part 2. Сборка

- **В файле _gitlab-ci.yml_ добавили этап запуска сборки через мейк файл из проекта _C2_, и файлы, полученные после сборки (артефакты), сохранили в произвольную директорию со сроком хранения 30 дней.**
![image](./images/2.1.png)

- **Запушили изменения и убедились, что всё работает**
![image](./images/2.2.png)
![image](./images/2.3.png)

## Part 3. Тест кодстайла

- **Написали этап для **CI**, который запускает скрипт кодстайла (*clang-format*)**
![image](./images/3.1.png)

> allow_failure: false - это настройка, которая указывает системе выполнения задач (например, системе непрерывной интеграции или сборке) не разрешать выполнение следующей задачи, если текущая задача завершилась неудачно (с ошибкой).

- **Если кодстайл не прошел, то "зафейлили" пайплайн, и в пайплайне отобразили вывод утилиты *clang-format***
![image](./images/3.2.png)

- **Кодстайл прошел:**
![image](./images/3.3.png)

## Part 4. Интеграционные тесты

- **Написали этап для **CI**, который запускает наши интеграционные тесты из того же проекта:**
![image](./images/4.1.png)

- **Запускали этот этап автоматически только при условии, если сборка и тест кодстайла прошли успешно**
![image](./images/4.2.png)
![image](./images/4.3.png)
![image](./images/4.4.png)

- **Если тесты не прошли, то "зафейлили" пайплайн, и в пайплайне отобразили вывод, что интеграционные тесты успешно прошли / провалились**

**Прошли:**
![image](./images/4.5.png)

**Провалились:**
![image](./images/4.6.png)

## Part 5. Этап деплоя

- **Подняли вторую виртуальную машину *Ubuntu Server 20.04 LTS**
![image](./images/5.1.png)

- **Написали этап для **CD**, который "разворачивает" проект на другой виртуальной машине:**
![image](./images/5.2.png)

- **Запускали этот этап вручную при условии, что все предыдущие этапы прошли успешно**
![image](./images/5.3.png)
![image](./images/5.4.png)

- **Написать bash-скрипт, который при помощи **ssh** и **scp** копирует файлы, полученные после сборки (артефакты), в директорию */usr/local/bin* второй виртуальной машины**
![image](./images/5.5.png)

> Для подключения машин мы использовали внетренние сети.
> Разрешели доступ к /usr/local/bin из r2 машины `sudo chmod -R 777 /usr/local/bin`
> Сделали исполняемый файл deploy.sh `sudo chmod +x deploy.sh`

- **Создали внутренную сеть:**
![image](./images/5.6.png)
![image](./images/5.7.png)

- **Настроили файлы /etc/netplan/00-installer-config.yaml**
![image](./images/5.8.png)
![image](./images/5.9.png)

> Для подключение я машине r1 мы использовали команду `ssh -p 2222 swissmer@localhost`. Заранее открыли порт 2222
![image](./images/info.png)

- **Используя команду `sudo su - gitlab-runner`, зашли от имени gitlab-runner, проверили соединение c r2**
![image](./images/5.10.png)

- **Cгенерировали ключи(открытый/закрытый), скопировали открытый ключ в swissmer@10.10.0.2 (r2)**
![image](./images/5.11.png)

- **В файле _gitlab-ci.yml_ добавили этап запуска написанного скрипта и сохранили дампы образов виртуальных машин**
![image](./images/5.12.png)
![image](./images/5.13.png)

## Part 6. Дополнительно. Уведомления

- **Написали @botfather, чтобы создать бота в *Telegram***
![image](./images/6.1.png)

- **Написали скрипт**
![image](./images/6.2.png)

- **Добавили вызов скрипта после каждого этапа**
![image](./images/6.3.png)

- **Проверили функциональность**
![image](./images/6.4.png)

